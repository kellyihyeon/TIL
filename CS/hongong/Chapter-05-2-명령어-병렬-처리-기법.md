## 학습 키워드

- `명령어 파이프라이닝` `슈퍼스칼라` `비순차적 명령어 처리 기법`
- 명령어 병렬 처리 기법
    - 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법

---

# 명령어 파이프라인

- 명령어 처리 과정을 클럭 단위로 나누면 다음과 같다.
    1. 명령어 인출
    2. 명령어 해석
    3. 명령어 실행
    4. 결과 저장
- 같은 단계가 겹치지만 않는다면  CPU는 각 단계를 동시에 실행할 수 있다.

![](/CS/hongong/img/명령어_파이프라이닝.png)

- 공장 생산 라인과 같이 명령어들을 **명령어 파이프라인**에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝** 이라고 한다.
- 파이프라이닝이 높은 성능을 가져오기는 하지만 특정 상황에서는 성능 향상에 실패하는 경우도 있다. 이를 **파이프라인 위험** (pipeline hazard) 이라고 부른다.

![](/CS/hongong/img/파이프라인_위험.png)

## 데이터 위험 (data hazard)

- 명령어 간 **‘데이터 의존성’**에 의해 발생
- 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것
- 예시
    
    ```java
    명령어 1: R1 <- R2 + R3
    명령어 2: R4 <- R1 + R5
    ```
    
    - 명령어 1을 수행해야만 명령어 2를 수행할 수 있음
    - 명령어 2는 명령어 1의 데이터에 의존적임

## 제어 위험 (control hazard)

- 주로 분기 등으로 인한 **‘프로그램 카운터의 갑작스러운 변화’**에 의해 발생
- 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 쓸모가 없어짐

## 구조적 위험 (structure hazard)

- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생
- 자원 위험(resource hazard) 이라고도 부름

# 슈퍼스칼라 (superscalar)

- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 슈퍼스칼라 라고 함
- 여러 개의 명령어 파이프라인을 두는 기법
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 **슈퍼스칼라 프로세서** 또는 **슈퍼스칼라 CPU** 라고 함
- 슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 함
    - 멀티스레드 프로세서는 슈퍼스칼라 구조를 사용할 수 있음 (한 번에 여러 명령어를 인출,해석,실행 가능)
- 슈퍼스칼라 프로세서는 이론적으로는 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만, 파이프라인 위험의 문제 때문에 실제로 파이프라인 개수에 비례하여 빨라지지는 않음

# 비순차적 명령어 처리 (OoOE; Out-of-order execution)

- 명령어들을 순차적으로 실행하지 않는 기법 (명령어의 합법적인 새치기)
- **파이프라이닝**, **슈퍼스칼라** 기법은 모두 여러 명령어의 **순차적인 처리**를 상정하는 방법. 만약 모든 명령어를 순차적으로만 처리하면 파이프라인 위험과 같은 예상치 못한 상황에서 명령어 파이프라인은 멈춰버리게 됨.
- 명령어를 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 **파이프라인이 멈추는 것을 방지**하는 기법을 **비순차적 명령어 처리 기법** 이라고 함

## 순차적 명령어 처리 예시

```
메모리 N번지: M(N)
메모리 N번지에 M을 저장하라: M(N) <- M

1. M(100) <- 1
2. M(101) <- 2
3. M(102) <- M(100) + M(101)
4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3
```

- 3번 명령어를 실행하기 위해서는 1번과 2번 명령어 실행이 끝날 때까지 기다려야 함
- 명령어들을 순차적으로 실행되는 CPU로 실행한다면
    - 2번 명령어 실행이 끝날 때까지 3,4,5,6 명령어들은 대기

## 비순차적 명령어 처리 예시

```
1. M(100) <- 1
2. M(101) <- 2

4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3

3. M(102) <- M(100) + M(101)
```

- 명령어들 중 데이터 의존성이 전혀 없는 명령어들, 즉 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들이 있음
    - 4,5,6 명령어
- 순차적으로 명령어를 처리할 때보다 더 효율적으로 처리됨

## 순서를 바꿀 수 있는 명령어 처리 예시

```
1. M(100) <- 1
2. M(101) <- 2
3. M(102) <- M(100) + M(101) 
4. M(103) <- M(102) + M(101)
5. M(104) <- M(100)
```

- 3번 명령어와 1번 명령어의 순서를 바꿀 수 없는 것과 마찬가지로 4번 명령어와 1번 명령어는 순서를 바꿀 수 없음
    - 1번 명령어를 토대로 3번 명령어가 수행, 3번 명령어를 토대로 4번 명령어가 수행되기 때문
- 4번 명령어와 5번 명령어는 어떤 의존성도 없기 때문에 순서를 바꿀 수 있음