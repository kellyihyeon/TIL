## 학습 키워드

- `프로그램 입출력` `메모리 맵 입출력` `고립형 입출력` `인터럽트 기반 입출력` `DMA 입출력` `입출력 버스`
- 장치 컨트롤러는 CPU와 어떻게 정보를 주고받을까?

---

# 프로그램 입출력(programmed I/O)

- 기본적으로 프로그램 속 명령어로 입출력장치를 제어하는 방법
- CPU가 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력장치에 연결된 장치 컨트롤러와 상호작용하며 입출력 작업을 수행함
- 프로그램 입출력 방식에서의 입출력 작업은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어짐

## 메모리에 저장된 정보를 하드 디스크에 백업한다면?

*== 하드 디스크에 새로운 정보를 쓴다.*

![](/CS/hongong/img/프로그램_입출력_1.png)

- CPU는 하드 디스크 컨트롤러의 **제어 레지스터**에 **쓰기** 명령을 보냄

![](/CS/hongong/img/프로그램_입출력_2.png)

- 하드 디스크 컨트롤러는 하드 디스크 상태를 확인
- 하드 디스크가 준비된 상태라면 하드 디스크 컨트롤러는 **상태 레지스터**에 준비되었다고 표시

![](/CS/hongong/img/프로그램_입출력_3.png)

- ⓵ CPU는 상태 레지스터를 주기적으로 읽으면서 하드 디스크의 준비 여부를 확인
- ⓶ 하드 디스크가 준비됐음을 CPU가 알게 되면 백업할 메모리의 정보를 데이터 레지스터에 씀

## CPU가 장치 컨트롤러의 레지스터에 접근하는 방식

- CPU 내부에 있는 레지스터들과 달리 CPU는 여러 장치 컨트롤러의 레지스터들을 모두 알고 있기는 어려움

### 메모리 맵 입출력(memory-mapped I/O)

- 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
- 가령 1024개의 주소를 표현할 수 있는 컴퓨터가 있을 때 512개는 메모리 주소, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용

![](/CS/hongong/img/메모리_맵_입출력.png)
- 주소 공간 예시
    - 516번지: 프린터 컨트롤러의 데이터 레지스터
    - 517번지: 프린터 컨트롤러의 상태 레지스터
    - 518번지: 하드 디스크 컨트롤러의 데이터 레지스터
    - 519번지: 하드 디스크 컨트롤러의 상태 레지스터

- CPU는 ‘517번지를 읽어 들여라’ 라는 명령어로 프린터 상태를 읽을 수 있음
- ‘518번지에 a를 써라’ 라는 명령어로 하드 디스크 컨트롤러의 데이터 레지스터로 데이터를 보낼 수 있음
- 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 다를 필요가 없음

### 고립형 입출력(isolated I/O)

- 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법

![](/CS/hongong/img/고립형_입출력.png)

![](/CS/hongong/img/고립형_입출력_버스.png)

- 가령 1024개의 주소를 표현할 수 있는 컴퓨터가 있을 때 제어 버스에 ‘메모리 읽기/쓰기’ 선 이외에 ‘입출력장치 읽기/쓰기’ 선이 따로 있다면 메모리에도 1024개의 주소 공간을 활용, 입출력장치도 1024개의 주소 공간을 활용
- 메모리 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 메모리에 접근
- 입출력장치 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 장치 컨트롤러에 접근
- CPU는 입출력장치에 접근하기 위해서 메모리에 접근하는 명령어와는 다른 입출력 명령어를 사용

### 메모리 맵 입출력과 고립형 입출력 요약

|  | 메모리 맵 입출력 | 고립형 입출력 |
| --- | --- | --- |
| 주소 공간 | 메모리와 입출력장치는 같은 주소 공간 사용 | 메모리와 입출력장치는 분리된 주소 공간 사용 |
| 메모리 주소 공간 | 메모리 주소 공간이 축소됨 | 메모리 주소 공간이 축소되지 않음 |
| 명령어 | 메모리와 입출력장치에 같은 명령어 사용 가능 | 입출력 전용 명령어 사용 |