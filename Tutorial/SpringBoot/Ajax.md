# 회원가입 시 Ajax를 사용하는 2가지 이유

# 1. 요청에 대한 응답을 html이 아닌 Data(Json)를 받기 위해서
## 1.1 웹브라우저
```   
클라이언트   ① 요청(회원가입 화면)     서버
┌──────┐ ───────────────────────> ┌──────┐
│ ④ A  │                          │  ② B │
└──────┘ <─────────────────────── └──────┘
                ③ .html
```

- 회원가입 자체를 요청하면 서버는 회원가입을 수행하고, 이에 대한 응답을 해줄 때 보통은 메인 화면을 다시 return 해준다.
<br>

## 1.2 앱
- 클라이언트가 항상 브라우저이기만 할 리는 없다.  
클라이언트가 앱이라고 가정해보자. 앱은 웹 브라우저가 아니다.  
앱이 안드로이드라면 화면 디자인을 자바 코드로 하게된다.  

```   
               회원가입               회원가입 수행
┌────────┐ ───────────────>┌──────┐────────────────>┌──────┐
│ app    │                 │server│                 │  DB  │
└────────┘ <────────────── └──────┘<────────────────└──────┘
               .html                      정상
```
- html 을 return 해주면 앱은 작동하지 않는다.  
앱은 단순히 데이터만 return 해주면된다.   
화면 디자인은 앱에 이미 자바코드로 자체적으로 되어있다.
정상이라는 data를 전달하면 앱에서는 단순히 화면만 이동시키면 된다.  

- 반면에 브라우저는 미리 프로그램을 다운받을 수 없고 항상 요청을 해서 페이지를 받는 방식이다.  
  
- 브라우저와 앱은 응답 받는 형태가 다르다. 
그렇다면 서버를 두 번 만들어야하는데 서버를 두 번 만들바에야 data를 return 하는 서버로 하나만 만들면 된다.  
<br>

## 1.3 data를 응답하는 서버

```   
               회원가입               회원가입 수행
┌────────┐ ───────────────>┌──────┐────────────────>┌──────┐
│browser │                 │server│                 │  DB  │
└────────┘ <────────────── └──────┘<────────────────└──────┘
              data(정상)                   정상
```
- 이후 브라우저는 서버에 회원가입 화면을 request 하고, 서버는 이때 .html 파일을 response 해주면 된다.


```   
               회원가입               회원가입 수행
┌────────┐ ───────────────>┌──────┐────────────────>┌──────┐
│ app    │                 │server│                 │  DB  │
└────────┘ <────────────── └──────┘<────────────────└──────┘
              data(정상)                   정상
```
- 이후 앱은 앱 내부에서 화면을 이동하기만 하면 된다.
(앱은 화면을 이미 들고 있기 때문에 가능)
<br>
<br>


# 2. 비동기 통신을 하기 위해서
## 2.1 동기적
- 프로그램은 일을 순서에 맞게 처리한다.

- 순차적으로 ① -> ② -> ③ -> ④ -> ⑤ 를 처리한다.

- ① 화면을 그린다. (내장) `[cpu]`  
  ② 단순 연산을 한다. `[cpu]`  
  ③ 도라에몽 이미지 파일을 다운로드 한다. (외부)    
  `[기억장치(RAM) + 저장장치(HDD)]`  
  ④ 도라에몽 그림을 그린다. `[cpu]`   
  ⑤ 화면에 그림을 그린다. (내장) `[cpu]`  

- ③ 도라에몽 파일을 다운로드 받는 데 10초가 걸린다고 가정하자. (pending)  
다운로드가 되고 있는 10초 동안은 다운로드가 끝나지 않았으니 ④번, ⑤번 작업을 하지 못한다.

- 결국 사용자 경험이 나빠지고, 이는 앱 사용률 하락으로 이어진다.
<br>

## 2.2 비동기적
- 다운로드를 하는 데 10초가 걸리니 이를 비동기 처리한다.  
비동기란 일을 순서에 맞지 않게 처리한다는 의미이다.  
① 실행 -> ② 실행 -> ③ 실행 (비동기처리)

- ③ 을 실행하면서 일어나는 일을 살펴보자.  
    cpu는 저장장치에게 도라에몽 파일을 다운받으라고 던져버린다.  

    cpu: "나는 ④ 도라에몽 그림 그리러 갈게. 아... 근데 다운을 안받았는데 어떻게 그리지? 야 이것도 너가 처리해."  

    HDD: "아 이거는 연산장치라서 저장장치인 나는 못하는데?"  

    cpu: "아 맞네? 그럼 일단 나는 ⑤번 그리고 올게. 그리고 있을 테니까 니가 다운 다 받으면 나 호출해줘. 그럼 내가 그때 ④번 그릴게."  

- ③번 처럼 다운로드해서 저장장치에 기록하는 것을 IO가 일어나고 있다고 말한다.  
cpu는 IO가 일어나는 동안에는 ⑤ 화면에 그림을 그리러 간다.  

### 2.2.1 콜백
- ④번을 아직 하지 않은 상황이고, cpu는 ⑤번을 하고 있는 중이거나 다 했다면 저장 장치가 pending을 끝내고 나면 (다운로드 완료) 쉬고 있는 cpu 혹은 그림을 그리고 있는 cpu에게 알려준다.  
"다운로드 다 받았어. 도라에몽 그려야 돼." 라고 알려주면  cpu는 하던 일을 멈추고 도라에몽을 그리러간다.   
이를 **`콜백`** 이라 한다. (하던 일을 멈추고 다시 돌아간다.)

- cpu가 ⑤번을 완료하고 쉬고 있을 때 돌아가는 것과 ⑤번 일을 하고 있다가 이를 멈추고 돌아가는 것은 다르다.

- ⑤번을 절반 정도 그리다가 도라에몽을 그리러 올라가고 도라에몽을 다 그리고 다시 내려왔으면 그 하던 일 그 뒤에서부터 일을 시작하고 마무리를 지으면 된다.  
이런 것을 `비동기적 실행`이라고 한다.  
  - 동기적 실행이라는 것은 절차적으로 일을 실행 하는 것이고  무조건 앞에 있는 작업이 끝이나야 뒤가 실행된다.

- ③번 작업이 끝나지 않았는데 ⑤번 작업을 실행할 수 있다는 것을 비동기적 실행이라 한다.